<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Shakalizer — fixed (vertical video + effects)</title>
<style>
  :root{--bg:#000;--accent:#ff2d55;--muted:#111;--txt:#9fd;}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,Roboto,Arial;}
  .topbar{position:fixed;left:0;right:0;top:0;padding:10px;background:rgba(0,0,0,0.6);display:flex;gap:8px;align-items:center;z-index:40}
  .btn{background:var(--accent);border:none;color:#fff;padding:8px 12px;border-radius:10px;font-weight:700}
  .btn2{background:#222;color:#ddd;padding:8px 10px;border-radius:8px;border:1px solid #333}
  #wrap{padding-top:60px;display:flex;flex-direction:column;align-items:center;gap:12px}
  #viewer{width:100%;max-width:980px;padding:6px;box-sizing:border-box}
  canvas{width:100%;height:auto;border-radius:10px;display:block;background:#000}
  #controls{width:100%;max-width:980px;padding:6px;box-sizing:border-box;display:flex;flex-direction:column;gap:10px}
  .row{display:flex;align-items:center;gap:12px}
  label{min-width:100px;color:var(--txt);font-size:15px}
  input[type=range]{flex:1}
  .val{width:42px;text-align:right;color:#afa;font-size:13px}
  .hint{font-size:12px;color:#999}
  .spacer{height:80px}
</style>
</head>
<body>

<div class="topbar">
  <button id="startBtn" class="btn">START</button>
  <button id="loadBtn" class="btn2">LOAD VIDEO</button>
  <button id="stopBtn" class="btn2">STOP</button>
  <div style="flex:1"></div>
  <div style="font-size:13px;color:#aaa">SHAKALIZER — fixes</div>
</div>

<div id="wrap">
  <div id="viewer">
    <canvas id="canvas"></canvas>
  </div>

  <div id="controls">
    <div class="row">
      <label for="destructionSlider">destruction</label>
      <input id="destructionSlider" type="range" min="0" max="100" value="0">
      <div id="destrVal" class="val">0</div>
    </div>

    <div class="row">
      <label for="glitchSlider">glitch</label>
      <input id="glitchSlider" type="range" min="0" max="100" value="0">
      <div id="glitchVal" class="val">0</div>
    </div>

    <div class="hint">Порядок: START → LOAD VIDEO. Первый тап по странице разблокирует звук.</div>
  </div>

  <div class="spacer"></div>
</div>

<script>
/* Single-file engine with fixes:
   - canvas sizing uses video.videoWidth/video.videoHeight (vertical videos OK)
   - effects applied to full canvas (getImageData over whole backing size)
   - sliders wired to setDestruction / setGlitch
*/

const startBtn = document.getElementById('startBtn');
const loadBtn = document.getElementById('loadBtn');
const stopBtn = document.getElementById('stopBtn');

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const destrSlider = document.getElementById('destructionSlider');
const glitchSlider = document.getElementById('glitchSlider');
const destrVal = document.getElementById('destrVal');
const glitchVal = document.getElementById('glitchVal');

let devicePR = window.devicePixelRatio || 1;

// state variables (global-ish)
let destruction = 0;
let glitch = 0;

function setDestruction(v){ destruction = v; }
function setGlitch(v){ glitch = v; }

// Helper: set canvas backing size based on video natural size
function setCanvasToVideoSize(video){
  // use natural video size as backing pixels
  const vw = video.videoWidth || 640;
  const vh = video.videoHeight || 360;
  // set backing size (use devicePixelRatio to keep quality)
  canvas.width = Math.round(vw * devicePR);
  canvas.height = Math.round(vh * devicePR);
  // set displayed CSS size to match video aspect ratio and fit screen width
  const cssW = Math.min(window.innerWidth, vw);
  const cssH = Math.round(cssW * (vh / vw));
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  // set transform so drawing coordinates are in CSS pixels
  ctx.setTransform(devicePR, 0, 0, devicePR, 0, 0);
}

// Engine
let videoEl = null;
let raf = null;

function startRenderLoop(){
  if(raf) return;
  function draw(){
    raf = requestAnimationFrame(draw);
    if(!videoEl || videoEl.readyState < 2) return;

    // draw into canvas (note: ctx transform set to devicePixelRatio)
    const cssW = canvas.width / devicePR;
    const cssH = canvas.height / devicePR;

    ctx.clearRect(0,0, cssW, cssH);

    // draw video into CSS pixels area (cover)
    const vw = videoEl.videoWidth || cssW;
    const vh = videoEl.videoHeight || cssH;
    // compute scale to cover canvas
    const scale = Math.max(cssW / vw, cssH / vh);
    const dw = vw * scale;
    const dh = vh * scale;
    const dx = (cssW - dw) / 2;
    const dy = (cssH - dh) / 2;
    ctx.drawImage(videoEl, 0,0, vw, vh, dx, dy, dw, dh);

    // APPLY EFFECTS to entire backing pixel area
    if(destruction > 0 || glitch > 0){
      try{
        // operate on full backing pixels
        const img = ctx.getImageData(0, 0, cssW, cssH); // coords in CSS pixels because transform applied
        const data = img.data;

        // destruction: random colored pixels across whole image
        for(let i = 0; i < data.length; i += 4){
          if(Math.random() < destruction * 0.08){
            data[i] = 255;
            data[i+1] = Math.floor(Math.random()*255);
            data[i+2] = Math.floor(Math.random()*255);
          }
        }

        // glitch: horizontal line shifts
        for(let y = 0; y < cssH; y++){
          if(Math.random() < glitch * 0.2){
            const shift = (Math.random()*80 - 40) | 0;
            // get row
            const row = ctx.getImageData(0, y, cssW, 1);
            ctx.putImageData(row, shift, y);
          }
        }

        ctx.putImageData(img, 0, 0);
      }catch(e){
        // getImageData can throw on some devices for big canvases; ignore gracefully
        // console.warn('effects skipped', e);
      }
    }
  }
  draw();
}

function stopRenderLoop(){
  if(raf) cancelAnimationFrame(raf);
  raf = null;
}

// init video element and wiring
async function initEngine(){
  if(videoEl) return; // already
  videoEl = document.createElement('video');
  videoEl.playsInline = true;
  videoEl.muted = true;
  videoEl.loop = true;
  videoEl.style.display = 'none';
  document.body.appendChild(videoEl);

  videoEl.onloadeddata = function(){
    // *** FIX FOR PROBLEM 1: set canvas size to video natural size ***
    setCanvasToVideoSize(videoEl);
    // start playing (muted is allowed)
    videoEl.play().catch(()=>{});
    // start render loop
    startRenderLoop();
  };

  // when metadata loaded but before play, ensure canvas size
  videoEl.onloadedmetadata = function(){
    // set canvas right away to avoid flicker
    setCanvasToVideoSize(videoEl);
  };

  // unmute on user tap (once)
  document.body.addEventListener('click', ()=>{
    if(videoEl){
      try{ videoEl.muted = false; videoEl.play().catch(()=>{}); }catch(e){}
    }
  }, { once: true });
}

// load file (from input)
function openFilePickerAndLoad(){
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'video/*,audio/*';
  input.onchange = (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    if(!videoEl) initEngine().then(()=>{ videoEl.src = url; });
    else videoEl.src = url;
    // play attempt
    videoEl.play().catch(()=>{});
  };
  input.click();
}

// wiring UI buttons & sliders
startBtn.addEventListener('click', async ()=>{
  await initEngine();
  // enable load if needed (load button already present)
});

loadBtn.addEventListener('click', ()=> openFilePickerAndLoad());
stopBtn.addEventListener('click', ()=>{
  if(videoEl){
    try{ videoEl.pause(); videoEl.src = ''; }catch(e){}
  }
  stopRenderLoop();
});

// sliders wiring (problem 2)
destrSlider.addEventListener('input', (e)=>{
  const v = Number(e.target.value)/100;
  destrVal.textContent = Math.round(v*100);
  setDestruction(v);
});
glitchSlider.addEventListener('input', (e)=>{
  const v = Number(e.target.value)/100;
  glitchVal.textContent = Math.round(v*100);
  setGlitch(v);
});

// responsive: if window resizes and video is present, adjust displayed CSS size
window.addEventListener('resize', ()=>{
  if(videoEl && videoEl.videoWidth && videoEl.videoHeight){
    setCanvasToVideoSize(videoEl);
  }
});

// initial canvas placeholder size
canvas.style.width = Math.min(window.innerWidth, 720) + 'px';
canvas.style.height = Math.round((Math.min(window.innerWidth,720) * 9/16)) + 'px';
</script>
</body>
</html>
