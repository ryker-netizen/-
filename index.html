<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Shakalizer - mobile single file</title>
<style>
  :root{--bg:#000;--accent:#ff2d55;--muted:#222;}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  .topbar{position:fixed;left:0;right:0;top:0;padding:12px;background:rgba(0,0,0,0.65);display:flex;gap:10px;align-items:center;z-index:30}
  .btn{background:var(--accent);border:none;color:#fff;padding:10px 14px;border-radius:12px;font-weight:600;font-size:16px}
  .small{background:#111;padding:8px 10px;border-radius:10px;color:#ddd}
  #wrap{padding-top:66px;display:flex;flex-direction:column;align-items:center;gap:10px;}
  #viewer{width:100%;max-width:980px;display:flex;flex-direction:column;align-items:center;padding:10px;box-sizing:border-box}
  canvas{width:100%;height:auto;border-radius:8px;background:#000;display:block}
  #controls{width:100%;max-width:980px;padding:12px;box-sizing:border-box;display:flex;flex-direction:column;gap:10px}
  .row{display:flex;align-items:center;gap:12px}
  label{min-width:90px;color:#9f9;font-size:16px}
  input[type=range]{flex:1}
  @media (max-width:600px){
    .topbar{padding:8px}
    .btn{font-size:15px;padding:10px}
    label{min-width:90px;font-size:15px}
  }
  /* keep bottom space for nav */
  .spacer{height:80px}
</style>
</head>
<body>

<div class="topbar">
  <button id="startBtn" class="btn">START</button>
  <button id="loadBtn" class="small">LOAD VIDEO</button>
  <div style="flex:1"></div>
  <div style="font-size:13px;color:#aaa">SHAKALIZER v3 (mobile)</div>
</div>

<div id="wrap">
  <div id="viewer">
    <canvas id="screen"></canvas>
  </div>

  <div id="controls">
    <div class="row">
      <label for="destruction">destruction</label>
      <input id="destruction" type="range" min="0" max="100" value="0">
    </div>

    <div class="row">
      <label for="glitch">glitch</label>
      <input id="glitch" type="range" min="0" max="100" value="0">
    </div>
  </div>

  <div class="spacer"></div>
</div>

<script type="module">
/* Single-file mobile engine -- paste this whole file and replace existing index.html */
/* Quick explanation: start -> init engine. load -> choose file. sliders -> control effects. */

const startBtn = document.getElementById('startBtn');
const loadBtn  = document.getElementById('loadBtn');
const canvas   = document.getElementById('screen');
const ctx      = canvas.getContext('2d');

const destrSlider = document.getElementById('destruction');
const glitchSlider = document.getElementById('glitch');

let state = {
  destruction: 0.0,
  glitch: 0.0
};

let engine = null; // will hold returned API

// Resize canvas to mobile-friendly size
function resizeCanvas(){
  const w = Math.min(window.innerWidth, 980);
  // use portion of viewport height so controls visible
  const h = Math.max( Math.min(window.innerHeight*0.58, Math.floor(w*9/16)), 120);
  canvas.width = Math.floor(w * devicePixelRatio);
  canvas.height = Math.floor(h * devicePixelRatio);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Simple engine factory
async function initVideoEngine(){
  // Only one video element internally, created here
  const video = document.createElement('video');
  video.playsInline = true;
  video.muted = true; // start muted; we will unmute on user gesture
  video.loop = true;
  video.crossOrigin = "anonymous";
  video.style.display = 'none';
  document.body.appendChild(video);

  let playing = false;
  let rafId = null;

  function drawFrame(){
    rafId = requestAnimationFrame(drawFrame);

    if(!video || video.readyState < 2) return;

    // draw video to canvas sized element area (canvas CSS size)
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const cw = canvas.width / devicePixelRatio;
    const ch = canvas.height / devicePixelRatio;

    // draw with covering scale (fit width)
    let vw = video.videoWidth || cw;
    let vh = video.videoHeight || ch;
    // fit to canvas width, keep aspect
    const scale = Math.max(cw / vw, ch / vh);
    const dw = vw * scale;
    const dh = vh * scale;
    const dx = (cw - dw) / 2;
    const dy = (ch - dh) / 2;

    ctx.drawImage(video, 0, 0, vw, vh, dx, dy, dw, dh);

    // apply destruction/glitch effects (cheap and mobile-friendly)
    const g = state.glitch;
    const d = state.destruction;

    // small pixel-shift / color-scramble
    if(g > 0.001 || d > 0.001){
      try {
        const img = ctx.getImageData(0,0,cw, ch);
        const data = img.data;
        const len = data.length;
        // glitch: random bright pixels based on g
        const chance = Math.min(0.35, g * 0.25);
        for(let i = 0; i < len; i += 4 * 8){
          if(Math.random() < chance){
            // red burst
            data[i] = 255;
            data[i+1] = Math.random() < 0.5 ? 0 : data[i+1];
            data[i+2] = Math.random() < 0.5 ? 0 : data[i+2];
          }
        }

        // destruction: horizontal slices jitter
        if(d > 0.001){
          const rows = Math.floor(6 + d * 20);
          for(let r = 0; r < rows; r++){
            const y = Math.floor(Math.random() * ch);
            const h = Math.max(1, Math.floor(1 + d * 8 * Math.random()));
            const shift = Math.floor((Math.random() - 0.5) * d * 60);
            if(shift === 0) continue;
            const srcY = Math.min(Math.max(0, y), ch-1);
            const slice = ctx.getImageData(0, srcY, cw, h);
            ctx.putImageData(slice, shift, srcY);
          }
        }

        ctx.putImageData(img, 0, 0);
      }catch(e){
        // getImageData may throw on some devices with cross-origin / huge canvases: ignore gracefully
        // console.warn('effect skip', e);
      }
    }
  }

  // start / stop and API
  function startRendering(){
    if(!rafId) drawFrame();
  }

  function stopRendering(){
    if(rafId) cancelAnimationFrame(rafId);
    rafId = null;
  }

  async function loadVideoFile(file){
    if(!file) return;
    try {
      // revoke old url(s) later?
      const url = URL.createObjectURL(file);
      video.src = url;
      // ensure video tries to load and play (may require user gesture)
      await video.load();
      // attempt play; may be blocked if not unmuted and no gesture, but video.muted is true so should play
      video.play().catch(()=>{});
      playing = true;
      startRendering();
    } catch(err){
      console.error('load fail', err);
    }
  }

  function unmute(){
    try {
      video.muted = false;
      video.volume = 1.0;
      video.play().catch(()=>{});
    } catch(e){}
  }

  // expose API
  return {
    loadVideo: loadVideoFile,
    unmute,
    stop(){
      if(video){ video.pause(); video.src=''; }
      stopRendering();
    },
    setDestruction(v){ state.destruction = v; },
    setGlitch(v){ state.glitch = v; }
  };
}

// UI wiring
startBtn.addEventListener('click', async ()=>{
  if(engine) return; // already started
  engine = await initVideoEngine();

  // wire load button to file picker
  loadBtn.addEventListener('click', ()=>{
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'video/*,audio/*';
    input.onchange = (e)=>{
      const f = e.target.files && e.target.files[0];
      if(f && engine) engine.loadVideo(f);
    };
    input.click();
  });

  // unmute on first tap (user gesture)
  document.body.addEventListener('click', ()=>{
    if(engine && engine.unmute) engine.unmute();
  }, { once: true });

  // sliders
  destrSlider.addEventListener('input', (e)=>{
    const v = Number(e.target.value) / 100;
    state.destruction = v;
    if(engine && engine.setDestruction) engine.setDestruction(v);
  });

  glitchSlider.addEventListener('input', (e)=>{
    const v = Number(e.target.value) / 100;
    state.glitch = v;
    if(engine && engine.setGlitch) engine.setGlitch(v);
  });

  // small UX: automatically open file picker once, optional
  // loadBtn.click();
});

// safety: if user refreshes and engine exists, reconnect UI (unlikely)
window.addEventListener('load', ()=>{
  resizeCanvas();
});

</script>
</body>
</html>
